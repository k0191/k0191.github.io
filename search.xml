<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【C语言笔记】变量</title>
    <url>/posts/20230625/231208.html</url>
    <content><![CDATA[<div class="note blue no-icon flat"><p>本文为刚毕业参加工作时，初学C语言时做的一些笔记，适合初学者读阅，内容不保证百分百正确，若您对其中的描述有任何疑问可在留言板块进行留言。</p>
<p>以下为我使用的C语言的运行和编译环境：<br>System Version: <a href="https://cn.ubuntu.com/blog/upgrade-your-desktop-ubuntu-22-04-lts-cn">Ubuntu22.04.1</a><br>Linux kernel Version: <a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/">5.19.0</a><br>GCC Version: 11.3.0<br>STDC VERSIOn: 201710L</p>
<p><strong>摘要：</strong> 简单的描述了C语言中的变量的分类、作用域、生命周期等内容，对<code>static</code>、<code>extern</code>、<code>const</code>、<code>volaite</code>关键字对变量的作用进行了简要分析。</p>
</div>
<h1 id="1-变量的分类"><a href="#1-变量的分类" class="headerlink" title="1. 变量的分类"></a>1. 变量的分类</h1><ul>
<li><p>局部变量：在代码块中定义的变量叫做局部变量。局部变量具有临时性。局部变量的作用域是。进入代码块中，没有被 <code>static</code> 修饰符修饰定义的变量，自动形成局部变量，退出代码块时该变量自动释放。</p>
</li>
<li><p>全局变量：在所有函数外定义的变量，叫做全局变量。全局变量具有全局性。</p>
</li>
</ul>
<p>代码块：用 <code>&#123;&#125;</code> 括起来的一个区域，就叫做代码块。花括号可以嵌套，最外层花括号定义的变量可以作用于内层花括号中，而内层花括号中定义的变量不可作用于外层花括号。</p>
<h1 id="2-变量的作用域"><a href="#2-变量的作用域" class="headerlink" title="2. 变量的作用域"></a>2. 变量的作用域</h1><p>作用域：指的是该变量的可以被正常访问的代码区域，也就是变量的有效区域</p>
<ul>
<li>局部变量：只在本代码块内有效，从 <code>定义</code> 的位置起，到代码块结束。</li>
<li>全局变量：整个程序运行期间，都有效，从 <code>声明</code> 的位置起，直到文件结束。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">    a++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> func2（<span class="type">void</span>）</span><br><span class="line">&#123;</span><br><span class="line">    a--;</span><br><span class="line">    <span class="keyword">if</span> (expr) &#123;</span><br><span class="line">        b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b); <span class="comment">//输出 b = 2</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>a为全局变量，作用域从定义的一行起到文件结束，func1和func2都可以访问。</li>
<li>func2上方声明的b为全局变量，作用域从定义的一行起到文件结束，只有func2可以访问。</li>
<li>do-while结构中声明的b为局部变量，作用域为do while的整个结构，do while结束，则该变量被释放。若局部变量与全局变量同名，则在该局部变量的作用域内优先使用局部变量。</li>
</ul>
<h1 id="3-变量的生命周期"><a href="#3-变量的生命周期" class="headerlink" title="3. 变量的生命周期"></a>3. 变量的生命周期</h1><p>生命周期：指的是该变量从定义到被释放的时间范围，所谓的释放，指的是曾经开辟的空间”被释放”。</p>
<ul>
<li>局部变量：进入代码块，形成局部变量”开辟空间”，退出代码块，”释放”局部变量。</li>
<li>全局变量：定义完成之后，程序运行的整个生命周期内，该变量一直都有效。</li>
</ul>
<p>作用域和生命周期的区别：作用域更多的是指变量有效区域，也就是变量在哪里可以被访问到，而生命周期是一个时间概念，是指变量什么时候开辟和释放。</p>
<h1 id="4-变量的存储方式"><a href="#4-变量的存储方式" class="headerlink" title="4. 变量的存储方式"></a>4. 变量的存储方式</h1><ul>
<li>静态存储：在被分配内存单元后，内存单元的地址一直保持不变，不会被释放，直到程序结束。</li>
<li>动态存储：在程序执行的时候，使用他的时候才分配内存单元，使用完毕后立即释放，再使用在分配。</li>
</ul>
<h2 id="4-1-存储方式的修饰符"><a href="#4-1-存储方式的修饰符" class="headerlink" title="4.1. 存储方式的修饰符"></a>4.1. 存储方式的修饰符</h2><h3 id="4-1-1-auto"><a href="#4-1-1-auto" class="headerlink" title="4.1.1 auto"></a>4.1.1 auto</h3><p>在C语言中，变量的声明默认使用该关键字，变量自动使用默认的存储方式，一般不写明该关键字。<br>全局变量全部使用静态存储方式，局部变量默认使用动态存储方式。</p>
<h3 id="4-1-2-static"><a href="#4-1-2-static" class="headerlink" title="4.1.2 static"></a>4.1.2 static</h3><p>内部静态变量声明关键字，使用该关键字声明的变量使用静态存储方式。</p>
<h3 id="4-1-3-register"><a href="#4-1-3-register" class="headerlink" title="4.1.3 register"></a>4.1.3 register</h3><p>声明寄存器变量关键字，该关键字只能对局部非静态变量使用，即存储方式为动态存储方式，被该关键字声明的变量为寄存器变量，直接存储在CPU的寄存器中，提高该变量的访问效率。寄存器变量的类型只能是cha、int或指针类型。</p>
<h1 id="5-变量的链接属性"><a href="#5-变量的链接属性" class="headerlink" title="5. 变量的链接属性"></a>5. 变量的链接属性</h1><h2 id="5-1-翻译单元"><a href="#5-1-翻译单元" class="headerlink" title="5.1. 翻译单元"></a>5.1. 翻译单元</h2><p>符号（比如函数名或者变量）可以在其作用域内多次声明，但是只能定义一次，这就是 <code>ODR</code>（一个定义规则）。<br>变量的声明和定义往往是一起的，但可以使用 <code>extern</code> 关键字声明外部全局变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">0</span>; <span class="comment">//声明、定义、初始化全部完成</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b;   <span class="comment">//声明和定义，未进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> b; <span class="comment">//声明，声明变量b是具有外部链接属性的变量，一般放在头文件中</span></span><br></pre></td></tr></table></figure>
<p>程序是由一个或者多个翻译单元组成。</p>
<ul>
<li><p>翻译单元由实现文件以及它直接或者间接包含的所有标头组成。</p>
</li>
<li><p>实现文件通常具有 <code>c</code>、<code>cpp</code> 或 <code>cxx</code> 的文件扩展名。</p>
</li>
<li><p>标头文件通常具有 <code>h</code> 或 <code>hpp</code> 的文件扩展名。</p>
</li>
</ul>
<p>每个翻译单元都是由编译器单独编译的，编译完成之后，链接器会将编译的翻译单元合并到一个程序中，ODR的冲突通常显示为链接器错误。当同一名称在不同的翻译单元中具有两个不同的定义时，将会发生链接器链接错误。链接的概念仅适用于全局变量。链接的概念不适用于在代码块内声明的变量。</p>
<p>通常，使全局变量在多个文件中可见的最佳方式是将其放在标头文件中，然后在每个需要引用该变量的源文件中添加 <code>#include</code> 指令，将其包含到源文件中，通过在标头内容中添加 <code>#ifndef</code> 的声明保护，可以确保它声明的名称只被定义一次。</p>
<p>当然也可以通过 <code>#include</code> 一个源文件将其他源文件的内容置于同一个翻译单元中，但必须保证在进行翻译单元的链接时，所有的翻译单元中仅有一次定义。</p>
<h2 id="5-2-外部链接-extern"><a href="#5-2-外部链接-extern" class="headerlink" title="5.2. 外部链接(extern)"></a>5.2. 外部链接(extern)</h2><p>在程序的任何翻译单元中都可见，全局变量使用 <code>extern</code> 关键字进行声明。具有外部链接属性的变量，在所有翻译单元中只能被定义一次。</p>
<h2 id="5-3-内部链接-static"><a href="#5-3-内部链接-static" class="headerlink" title="5.3. 内部链接(static)"></a>5.3. 内部链接(static)</h2><p>只能在定义它的翻译单元中可见，全局变量使用 <code>static</code> 关键字进行声明。具有内部链接属性的变量，可以在其他翻译单元存在定义。</p>
<h1 id="6-变量的数据类型"><a href="#6-变量的数据类型" class="headerlink" title="6. 变量的数据类型"></a>6. 变量的数据类型</h1><p>数据类型用于定义变量在内存中所占用的内存大小，不同位数的编译器中数据的基本类型所占用的内存大小会有所不同，即数据类型所占用的空间大小由使用的编译器决定，可通过 <code>sizeof</code> 关键字求变量所占用的内存大小。</p>
<p>但有几条铁定的原则( <code>ANSI/ISO</code> 制订):</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">short</span> <span class="type">int</span>) &lt;= <span class="keyword">sizeof</span>(<span class="type">int</span>)</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>) &lt;= <span class="keyword">sizeof</span>(<span class="type">long</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">short</span> <span class="type">int</span>) &gt;= <span class="number">2</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">long</span> <span class="type">int</span>) &gt;= <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="6-1-基本类型"><a href="#6-1-基本类型" class="headerlink" title="6.1. 基本类型"></a>6.1. 基本类型</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">关键字</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">16位编译器（unit：Byte）</th>
<th style="text-align:center">32位编译器（unit：Byte）</th>
<th style="text-align:center">64位编译器（unit：Byte）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">signed char</td>
<td style="text-align:center">有符号字符型</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">unsigned char</td>
<td style="text-align:center">无符号字符型</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">signed short</td>
<td style="text-align:center">有符号短整型</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">unsigned short</td>
<td style="text-align:center">无符号短整型</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">signed int</td>
<td style="text-align:center">有符号整型</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">unsigned int</td>
<td style="text-align:center">无符号整型</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">signed long</td>
<td style="text-align:center">有符号长整型</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">unsigned long</td>
<td style="text-align:center">无符号长整型</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">单精度浮点型</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">双精度浮点型</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">void *</td>
<td style="text-align:center">指针变量</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">8</td>
</tr>
</tbody>
</table>
</div>
<h2 id="6-2-空类型"><a href="#6-2-空类型" class="headerlink" title="6.2. 空类型"></a>6.2. 空类型</h2><h3 id="6-2-1-void"><a href="#6-2-1-void" class="headerlink" title="6.2.1 void"></a>6.2.1 void</h3><p>指示对象为空类型(无类型)，即对象无可用的值。常用于函数的返回值或形参列表，表示函数无返回值，或函数调用时不需要传入参数。不可用于变量的声明。</p>
<p><code>sizeof(void) = 1</code></p>
<h2 id="6-3-构造类型"><a href="#6-3-构造类型" class="headerlink" title="6.3. 构造类型"></a>6.3. 构造类型</h2><h3 id="6-3-1-数组"><a href="#6-3-1-数组" class="headerlink" title="6.3.1. 数组"></a>6.3.1. 数组</h3><h4 id="6-3-1-1-数组的定义"><a href="#6-3-1-1-数组的定义" class="headerlink" title="6.3.1.1. 数组的定义"></a>6.3.1.1. 数组的定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">5</span>];      <span class="comment">//一维字符型数组，该数组所占用的内存大小为5个字节</span></span><br><span class="line"><span class="type">int</span> counts[<span class="number">5</span>];     <span class="comment">//一维整型数组，该数组所占用的内存大小为 5*sizeof(int) 个字节</span></span><br><span class="line"><span class="type">long</span> money[<span class="number">5</span>][<span class="number">10</span>]; <span class="comment">//二维长整型数组(5行10列)，该数组所占用的内存大小为 5*10*sizeof(int) 个字节</span></span><br></pre></td></tr></table></figure>
<p>注意：在使用较老的编译器时（仅支持C99之前标准的编译器），在定义数组时，数组的元素个数（[]内的数）需是常量表达式（C99标准开始支持变长数组，数组元素的个数可以是变量）。</p>
<h4 id="6-3-1-2-数组的初始化"><a href="#6-3-1-2-数组的初始化" class="headerlink" title="6.3.1.2. 数组的初始化"></a>6.3.1.2. 数组的初始化</h4><p>数组的初始化即给数组里放一些初始值，数组使用{}进行初始化，在大小给定的情况下，可以完全初始化，也可以不完全初始化（其余默认放0），在大小没有给定的情况下根据初始化内容确定数组的大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明、定义并初始化一个大小为5字节的字符类型数组,内容为&quot;hello&quot;</span></span><br><span class="line"><span class="type">char</span> str1[<span class="number">5</span>] = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明、定义并初始化一个大小为5字节的字符类型数组,内容为&quot;world&quot;</span></span><br><span class="line"><span class="type">char</span> str2[]  = &#123;<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明、定义并初始化一个大小为13字节的字符类型数组,内容为&quot;hello world!\0&quot;</span></span><br><span class="line"><span class="type">char</span> str3[] = <span class="string">&quot;hello world!&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>C语言中字符串的存储是以 <code>&#39;\0&#39;</code> 结束的，使用 <code>&quot;&quot;</code> 包含的字符为字符串常量，在内存中其最后一个位置处会被自动填充 <code>&#39;\0&#39;</code>。</p>
<h3 id="6-3-2-enum"><a href="#6-3-2-enum" class="headerlink" title="6.3.2. enum"></a>6.3.2. enum</h3><p>有些数据的取值往往是有限的，只能是非常少量的整型值，并且最好为每个值都取一个名称，以方便在后续代码中使用。这时就需要用枚举类型来为这些整型值定义一个明确含义的名称。枚举值默认从 0 开始，往后逐个加 1（递增）。</p>
<h4 id="6-3-2-1-枚举类型的定义"><a href="#6-3-2-1-枚举类型的定义" class="headerlink" title="6.3.2.1. 枚举类型的定义"></a>6.3.2.1. 枚举类型的定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个名叫week的枚举类型，其成员的值分别为&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span>Mon, Tues, Wed, Thurs, Fri, Sat, Sun&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个名叫dev_id的枚举类型，其成员的值分别为&#123;2, 3, 4&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">dev_id</span>&#123;</span>OPT_ID = <span class="number">2</span>, FPGA_ID = <span class="number">3</span>, DPD_ID = <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个名叫err_code的枚举类型，其成员的值分别为&#123;-1, 0, 1&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">err_code</span>&#123;</span>failed = <span class="number">-1</span>, ok, unexpected&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="6-3-2-2-枚举变量的定义"><a href="#6-3-2-2-枚举变量的定义" class="headerlink" title="6.3.2.2. 枚举变量的定义"></a>6.3.2.2. 枚举变量的定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个类型为week枚举类型的变量today，未初始化</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span> <span class="title">today</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个类型为BOOLEAN枚举类型的变量result，未初始化</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">BOOLEAN</span>&#123;</span>FALSE = <span class="number">0</span>, TRUE = <span class="number">1</span>&#125;result;</span><br></pre></td></tr></table></figure>
<h4 id="6-3-2-3-枚举变量的赋值"><a href="#6-3-2-3-枚举变量的赋值" class="headerlink" title="6.3.2.3. 枚举变量的赋值"></a>6.3.2.3. 枚举变量的赋值</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用week枚举变量的成员为today赋值，此时today = 0</span></span><br><span class="line">today = Mon;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个类型为dev_id枚举类型的变量dev, 并初始化为FPGA_ID，此时 dev = 3</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">dev_id</span> <span class="title">dev</span> =</span> FPGA_ID;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-3-struct"><a href="#6-3-3-struct" class="headerlink" title="6.3.3. struct"></a>6.3.3. struct</h3><p>结构体类型，将不同类型的数据组合成一个有机的整体。结构体的成员可以为变量，也可以是结构体变量，成员变量名可以程序中结构体外的定义的变量名相同。结构体变量所占内存长度是各成员占内存长度之和，每个成员分别占有其自己的内存单元。在实际的操作系统中存在内存对齐，结构体的整体大小是结构体中占用最大字节的成员的整数倍。</p>
<h4 id="6-3-3-1-结构体类型的定义"><a href="#6-3-3-1-结构体类型的定义" class="headerlink" title="6.3.3.1. 结构体类型的定义"></a>6.3.3.1. 结构体类型的定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个名叫student的结构体类型，成员有数组类型的name，无符号整型number，单精度浮点型score</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> number;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<h4 id="6-3-3-2-结构体变量的定义"><a href="#6-3-3-2-结构体变量的定义" class="headerlink" title="6.3.3.2. 结构体变量的定义"></a>6.3.3.2. 结构体变量的定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个student结构体类型的变量xiaoai，未初始化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">xiaoai</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义school结构体类型的变量qinghua和beida， 未初始化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">school</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> addr[<span class="number">100</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> NO;</span><br><span class="line">&#125;qinghua, beida;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个匿名结构类型的变量man，未初始化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">student</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">school</span> <span class="title">school</span>;</span></span><br><span class="line">&#125;man;</span><br></pre></td></tr></table></figure>
<h4 id="6-3-3-3-结构体变量的初始化与赋值"><a href="#6-3-3-3-结构体变量的初始化与赋值" class="headerlink" title="6.3.3.3. 结构体变量的初始化与赋值"></a>6.3.3.3. 结构体变量的初始化与赋值</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个student结构体类型的变量xiaoai，并初始化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">xiaoai</span> =</span> &#123;<span class="string">&quot;xiaoai&quot;</span>, <span class="number">0x170222</span>, <span class="number">59.0f</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用已定义的结构体变量xiaoai去初始化结构体变量xiaowen</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">xiaowen</span> =</span> xiaoai;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C风格初始化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">xiaohua</span> =</span> &#123;.number = <span class="number">0x170223</span>, .name = <span class="string">&quot;xiaohua&quot;</span>, .score = <span class="number">60.0f</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++风格初始化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">xiaofan</span> =</span> &#123;number : <span class="number">0x170224</span>, score : <span class="number">90.0f</span>, name : <span class="string">&quot;xiaofan&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">xiaoai.score = <span class="number">75.0f</span>;</span><br><span class="line">man = &#123;xiaoai, beida&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-4-union"><a href="#6-3-4-union" class="headerlink" title="6.3.4. union"></a>6.3.4. union</h3><p>联合体类型将不同类型的变量存放到同一段内存单元中，联合体变量的成员存放在同一个地址开始的内存单元，其首地址都相同，变量所占内存长度等于最长的成员的长度。联合体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员就失去作用。</p>
<h4 id="6-3-4-1-联合体类型的定义"><a href="#6-3-4-1-联合体类型的定义" class="headerlink" title="6.3.4.1. 联合体类型的定义"></a>6.3.4.1. 联合体类型的定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个名叫bin的联合体类型，sizeof(union bin) = 4</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bin</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> val8;</span><br><span class="line">    <span class="type">short</span> val16;</span><br><span class="line">    <span class="type">int</span> val32;</span><br><span class="line">    <span class="type">float</span> f32;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个名叫data的联合体类型，sizeof(long) = 8, sizeof(union data) = 16</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> bin[<span class="number">16</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> id;</span><br><span class="line">        <span class="type">char</span> sex;</span><br><span class="line">        <span class="type">short</span> age;</span><br><span class="line">        <span class="type">int</span> number;</span><br><span class="line">        <span class="type">long</span> hash;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//若调整定义变量的顺序, 则此时 sizeof(union data) = 24</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> bin[<span class="number">16</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> id;</span><br><span class="line">        <span class="type">char</span> sex;</span><br><span class="line">        <span class="type">short</span> age;</span><br><span class="line">        <span class="type">long</span> hash;</span><br><span class="line">        <span class="type">int</span> number;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="6-3-4-2-联合体变量的定义"><a href="#6-3-4-2-联合体变量的定义" class="headerlink" title="6.3.4.2. 联合体变量的定义"></a>6.3.4.2. 联合体变量的定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个bin联合体类型的变量value，未初始化</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bin</span> <span class="title">value</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个匿名联合体类型的变量key，未初始化</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;key;</span><br></pre></td></tr></table></figure>
<h4 id="6-3-4-3-联合体变量的初始化与赋值"><a href="#6-3-4-3-联合体变量的初始化与赋值" class="headerlink" title="6.3.4.3. 联合体变量的初始化与赋值"></a>6.3.4.3. 联合体变量的初始化与赋值</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接初始化</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bin</span> <span class="title">bit8</span> =</span> &#123;<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定成员初始化</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bin</span> <span class="title">bit16</span> =</span> &#123;.<span class="type">short</span> = <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用已定义的同类型联合体初始化</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bin</span> <span class="title">bit32</span> =</span> bit8;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bin</span> <span class="title">bit32f</span>;</span> </span><br><span class="line">bit32f.val32 = <span class="number">0xff00</span>;</span><br><span class="line">bit32f.val8 = <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bit32f.val32 = %x\n&quot;</span>, bit32f.val32);</span><br><span class="line"><span class="comment">// 输出 bit32f.val32 = ffff</span></span><br></pre></td></tr></table></figure>
<h2 id="6-4-指针类型"><a href="#6-4-指针类型" class="headerlink" title="6.4. 指针类型"></a>6.4. 指针类型</h2><p>C语言中将地址形象化的称为”指针”，一个变量的地址称为该变量的”指针”。指针是一个地址，而指针类型的变量是存放地址的变量。指针类型所占用的内存大小与操作系统的位数有关，基本上指针类型所占用的空间大小bit数等于操作系统的位数。</p>
<h3 id="6-4-1-指针类型变量的定义"><a href="#6-4-1-指针类型变量的定义" class="headerlink" title="6.4.1. 指针类型变量的定义"></a>6.4.1. 指针类型变量的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个指向char数据类型的指针变量pval8，该变量存放的值是char类型变量的首地址</span></span><br><span class="line"><span class="type">char</span> *pval8;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个指向float数据类型的指针变量pval32，该变量存放的值是float类型变量的首地址</span></span><br><span class="line"><span class="type">float</span> *pval32;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个空类型的指针变量pvoid，该变量存放的值是一个未知数据类型的变量的首地址</span></span><br><span class="line"><span class="type">void</span> *pvoid;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个指向enum week数据类型的指针变量pweek，该变量存放的值是enum week类型变量的首地址</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span> *<span class="title">pweek</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个指向struct student数据类型的指针变量pstu,该变量存放的值是struct student类型变量的首地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">pstu</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个指向union bin数据类型的指针变量pbin，该变量存放的值是union bin类型变量的首地址</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bin</span> *<span class="title">pbin</span>;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-4-2-指针类型变量的赋值"><a href="#6-4-2-指针类型变量的赋值" class="headerlink" title="6.4.2. 指针类型变量的赋值"></a>6.4.2. 指针类型变量的赋值</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将变量c的地址赋值给指针变量pval8</span></span><br><span class="line"><span class="type">char</span> *pval8 = &amp;c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C语言中NULL是((void *)0)的宏定义，即将指针变量赋空值，不指向任何有效地址</span></span><br><span class="line"><span class="type">int</span> *pval32 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将char类型的变量地址值赋值给空类型指针</span></span><br><span class="line"><span class="type">void</span> *pvoid = (<span class="type">void</span> *)&amp;c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将int类型的指针变量的值赋值给union bin类型的指针变量，并显示的转化其指针类型</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bin</span> *<span class="title">pbin</span> =</span> (<span class="keyword">union</span> bin *)pval32;</span><br></pre></td></tr></table></figure>
<h2 id="6-5-自定义类型"><a href="#6-5-自定义类型" class="headerlink" title="6.5. 自定义类型"></a>6.5. 自定义类型</h2><h3 id="6-5-1-typedef"><a href="#6-5-1-typedef" class="headerlink" title="6.5.1. typedef"></a>6.5.1. typedef</h3><p>typedef 关键字是为一种数据类型定义一个新名字，这里的数据类型包括基本数据类型（int，char等）、空类型、构造类型（struct等）。typedef 本身是一种存储类的关键字，与 auto、extern、static、register 等关键字不能出现在同一个表达式中。使用 typedef 定义的变量类型，其作用范围限制在所定义的函数或者文件内（取决于此变量定义的位置）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义一个新数据类型u8，该类型等效 unsigned char</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义一个新数据类型u16，该数据类型等效 unsigned short</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> u16;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义一个新数据类型string，该类型等效 unsigned char *</span></span><br><span class="line"><span class="keyword">typedef</span> u8 *<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义一个新数据类型student_t，该类型等效 struct student</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">student_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义一个新数据类型path，该类型是一个大小为64的数组，等效 unsigned char [64];</span></span><br><span class="line"><span class="keyword">typedef</span> u8 <span class="type">path_t</span>[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的使用</span></span><br><span class="line">u8 id = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">student_t</span> xiaoai = &#123;<span class="string">&quot;xiaoai&quot;</span>, <span class="number">170222</span>, <span class="number">59.0f</span>&#125;;</span><br><span class="line"><span class="type">path_t</span> local_path = <span class="string">&quot;/home/k0191/c-study&quot;</span>;</span><br></pre></td></tr></table></figure>
<h1 id="7-变量的类型限定符"><a href="#7-变量的类型限定符" class="headerlink" title="7. 变量的类型限定符"></a>7. 变量的类型限定符</h1><h2 id="7-1-const"><a href="#7-1-const" class="headerlink" title="7.1. const"></a>7.1. const</h2><p>const声明的变量为只读变量，在定义时必须初始化，且定义后不能在只读变量所在的作用域中被改变。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在定义时初始化，此后PI的值无法被修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> local_path1[<span class="number">64</span>] = <span class="string">&quot;/home/k0191/c-study&quot;</span>;</span><br><span class="line"><span class="type">char</span> local_path2[<span class="number">64</span>] = <span class="string">&quot;/home/k0191/cpp-study&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常量指针，无法通过c_path指针去修改数组local_path1的值，但可以修改c_path指针的值</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *c_path = local_path1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const char *与char const *等效</span></span><br><span class="line">c_path = local_path2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针常量，不可修改_cpath指针的值，但可以通过_cpath指针修改local_path1的值</span></span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> _cpath = local_path1;</span><br><span class="line">_cpath[<span class="number">6</span>] = <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不可修改ccpath指针的值，也不可用通过ccpath指针修改local_path1的值</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> ccpath = local_path1;</span><br></pre></td></tr></table></figure>
<ul>
<li>当一个 <strong><code>const</code></strong> 修饰的全局变量的值，被意外的改变时会引发程序崩溃。</li>
</ul>
<h2 id="7-2-volatile"><a href="#7-2-volatile" class="headerlink" title="7.2. volatile"></a>7.2. volatile</h2><p>volatile声明的变量为易变的变量。用这个限定符主要是让编译器在优化代码的时候不能优化此变量的取值，需要从原始位置进行取值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = a;</span><br><span class="line">    <span class="type">int</span> *ptr = &amp;a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用汇编，通过指针ptr修改变量a的值，让编译器无法感知a的值发生变化</span></span><br><span class="line">    <span class="keyword">asm</span> (<span class="string">&quot;mov %[var], (%[ptr])&quot;</span> : : [ptr] <span class="string">&quot;r&quot;</span>, [var] <span class="string">&quot;r&quot;</span> (<span class="number">20</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> c = a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d,  c = %d\n&quot;</span>, a, b, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当为编译器添加了 <strong><code>-O</code></strong> 选项后，编译器对这部分代码进行了优化，编译器在编译时发现有两个变量都使用了a，但是a的值在这之间并没有被使用。于是编译器在将a的值取出来之后，临时存放到了寄存器中，当变量c需要使用a的时候，编译器直接从寄存器中读取a的值，而不是从存储a的原始位置直接读取。结果就是输出打印 <code>a = 1, b = 1, c = 1</code>，而不是准确的 <code>a = 20, b = 1, c =20</code>。</p>
<p>在C语言项目中优化选项是必须的，而那些代表外部寄存器的值的变量的变化编译器是无法感知的，所以需要在这类变量前加上 <strong><code>volatile</code></strong> 关键词进行修饰，避免变量被编译器优化。</p>
<ul>
<li><p>volatile对应的变量可能在你的程序本身不知道的情况下发生改变，比如在多线程的程序中，共同访问的内存当中，多个程序都可以操纵这个变量，编译器是无法判定何时这个变量会发生变化，当变量表示一个外部设备的某个状态对应，当外部设备发生操作的时候，通过驱动程序和中断事件，系统改变了这个变量的数值，而编译器也是无法得知的。</p>
</li>
<li><p>对于volatile类型的变量，系统每次用到他的时候都是直接从对应的内存当中提取，而不会利用cache当中的原有数值，以适应它的未知何时会发生的变化，系统对这种变量的处理不会做优化——显然也是因为它的数值随时都可能变化的情况。</p>
</li>
<li><p>const 与 volatile 可同时修饰变量。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>【C语言笔记】表达式</title>
    <url>/posts/20230629/134737.html</url>
    <content><![CDATA[<div class="note blue no-icon flat"><p>本文为刚毕业参加工作时，初学C语言时做的一些笔记，适合初学者读阅，内容不保证百分百正确，若您对其中的描述有任何疑问可在留言板块进行留言。</p>
<p>以下为我使用的C语言的运行和编译环境：<br>System Version: <a href="https://cn.ubuntu.com/blog/upgrade-your-desktop-ubuntu-22-04-lts-cn">Ubuntu22.04.1</a><br>Linux kernel Version: <a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/">5.19.0</a><br>GCC Version: 11.3.0<br>STDC VERSIOn: 201710L</p>
<p><strong>摘要：</strong> </p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux笔记】简介</title>
    <url>/posts/20230629/135145.html</url>
    <content><![CDATA[<h1 id="TODO-💤"><a href="#TODO-💤" class="headerlink" title="TODO 💤"></a>TODO 💤</h1>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【C语言笔记】函数</title>
    <url>/posts/20230629/135028.html</url>
    <content><![CDATA[<div class="note blue no-icon flat"><p>本文为刚毕业参加工作时，初学C语言时做的一些笔记，适合初学者读阅，内容不保证百分百正确，若您对其中的描述有任何疑问可在留言板块进行留言。</p>
<p>以下为我使用的C语言的运行和编译环境：<br>System Version: <a href="https://cn.ubuntu.com/blog/upgrade-your-desktop-ubuntu-22-04-lts-cn">Ubuntu22.04.1</a><br>Linux kernel Version: <a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/">5.19.0</a><br>GCC Version: 11.3.0<br>STDC VERSIOn: 201710L</p>
<p><strong>摘要：</strong> 简单的描述了C语言中的函数的声明和定义、函数名的作用、堆和栈的区别、以及简述了如何在C语言中使用匿名函数。</p>
</div>
<h1 id="1-函数简介"><a href="#1-函数简介" class="headerlink" title="1. 函数简介"></a>1. 函数简介</h1><p>C语言中的函数可以抽象的理解为可轻松重复使用的代码块，它将一个个表达式和变量封装在一起，用来独立地完成某个功能。函数存在入口和出口，在入口处可以接收用户传递的参数，也可以不接收，在出口处可以将一些函数内部信息返回，也可以不返回任何信息。</p>
<p>将代码块封装成函数的过程叫做函数的定义。</p>
<h2 id="1-1-声明"><a href="#1-1-声明" class="headerlink" title="1.1. 声明"></a>1.1. 声明</h2><p>形参：函数原型中定义的参数，其作用域为整个函数。</p>
<p><code>[链接属性修饰符] 函数返回类型 函数名 (形参数据类型列表);</code></p>
<p>函数返回类型可以是任意的数据类型(包括基本类型、空类型、构造类型、指针类型、自定义类型)，当返回类型为<code>void</code>时，表明函数无返回值，函数体内可以无<code>return</code>语句。函数体中<code>return</code>语句返回的数据类型需与函数声明的函数返回类型相同。</p>
<p>函数的形参数据类型列表可以包含多个任意类型的参数，也可不写任何形参(不符合编程规范)。</p>
<p>在函数声明的形参数据类型列表中，可以只写明形参的数据类型，而不用书写变量名。</p>
<p>链接属性修饰符可不书写，默认为<code>extern</code>，一般将具有外部链接属性的函数声明放在头文件中，供其它翻译单元引用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明返回类型为void,形参列表为void的函数func1,该函数无任何返回值以及需要传入的参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明返回类型为void *,形参列表为int的函数func2,该函数返回void *类型值以及需要传入一个int类型的参数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func2</span> <span class="params">(<span class="type">int</span> a)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明可以存在多个,这里可以省略形参,编译器会根据函数的定义来确定函数的形参列表</span></span><br><span class="line"><span class="keyword">struct</span> school <span class="title function_">func3</span> <span class="params">(<span class="keyword">struct</span> student)</span>;</span><br><span class="line"><span class="keyword">struct</span> school <span class="title function_">func3</span> <span class="params">()</span>; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">err_code</span> <span class="title">err_code</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明具有内部链接属性,返回类型为err_code,形参列表为int的函数func4</span></span><br><span class="line"><span class="type">static</span> err_code <span class="title function_">func4</span> <span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明具有外部链接属性,返回类型为err_code,形参列表为const char *的函数func5</span></span><br><span class="line"><span class="keyword">extern</span> err_code <span class="title function_">func5</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br></pre></td></tr></table></figure>
<p>函数的声明是非必须的，若需要在不同的翻译单元中引用某个函数或不在该函数的作用域内引用，则需要在未定义该函数的翻译单元中进行函数声明，函数的声明应与函数的定义保持一致性。</p>
<h2 id="1-2-定义"><a href="#1-2-定义" class="headerlink" title="1.2. 定义"></a>1.2. 定义</h2><p><code>[链接属性修饰符] 函数返回类型 函数名 (形参列表) &#123;  函数体 &#125;</code></p>
<p>函数的定义即函数的实现，在一个程序所链接的所有的翻译单元中只能存在一个具有外部链接属性的函数实现(ODR:一个定义规则)，否则在编译时会出现链接器链接报错，但可以在不同的翻译单元中存在同名的具有内部链接属性的函数实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func1</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义具有内部属性的函数func2，其返回值为void *类型，形参为整型变量a</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">func2</span> <span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-函数的作用域"><a href="#1-3-函数的作用域" class="headerlink" title="1.3. 函数的作用域"></a>1.3. 函数的作用域</h2><p>就单一的翻译单元来说，其函数若未使用 <strong><code>static</code></strong> 关键字进行修饰和在任何其他地方进行声明，其作用域为从翻译单元的定义处一直到该翻译单元的结束位置。也可使用声明来扩展其作用域，函数被声明后，其作用域为声明处一直到该翻译单元的结束位置。</p>
<h1 id="2-函数调用"><a href="#2-函数调用" class="headerlink" title="2. 函数调用"></a>2. 函数调用</h1><h2 id="2-1-堆与栈"><a href="#2-1-堆与栈" class="headerlink" title="2.1. 堆与栈"></a>2.1. 堆与栈</h2><h3 id="2-1-1-栈"><a href="#2-1-1-栈" class="headerlink" title="2.1.1 栈"></a>2.1.1 栈</h3><p>栈是程序运行内存中的一个特别区域，它用来存储被每一个函数(包括 <strong><code>mian</code></strong> 函数)创建的动态存储局部变量，包括函数本身。栈是 <strong><code>FILO</code></strong> 结构体(First input Last output)，就是先进后出原则的结构体，它直接被CPU管理和充分利用。每次函数声明和定义一个新的局部变量时，它就会被 <strong><code>push</code></strong> 到栈中，然后在每次一个函数退出时，所有关于这个函数中定义的局部变量(包括形参)都会被释放(栈顶重新调整，释放处内存空间中的数据并不会被马上覆盖，而是等到下一个局部变量入栈时进行覆盖)。一旦栈中的变量释放，这块栈的区域就会变成可用的，提供给其他栈中的变量。用栈存储变量的好处是，其内存是被CPU直接管理的，不需要进行手动的创建内存和手动的释放内存。CPU组织和管理栈内存是很高效的，读出和写入栈中存储的变量是很快的。<br>栈的内存空间相对较小，在定义局部变量和调用函数时应考虑开辟的栈空间大小是否合适，避免造成栈溢出。</p>
<h3 id="2-1-2-堆"><a href="#2-1-2-堆" class="headerlink" title="2.1.2 堆"></a>2.1.2 堆</h3><p>堆也是程序运行内存中的一个特别区域，但不是被自动管理的内存区域，对堆内存的使用，需要进行手动的申请(C:malloc/C++:new)和手动释放(C:free/C++:delete)。如果手动申请一片堆区内存后，而不进行手动释放，在程序运行的过程中，此处堆内存不会被清理，其他变量也无法申请该区域的内存，此时会造成内存泄漏的问题。堆区内存比栈区内存空间大，但也是有限的，操作系统为程序分配的堆内存若被耗尽，则会被操作系统杀死该进程程序。若是在无操作系统管理的设备上造成内存泄漏，会使整个系统发生崩溃。</p>
<h3 id="2-1-3-栈和堆的优缺点"><a href="#2-1-3-栈和堆的优缺点" class="headerlink" title="2.1.3. 栈和堆的优缺点"></a>2.1.3. 栈和堆的优缺点</h3><ul>
<li>栈<ol>
<li>快速访问。</li>
<li>没有必要明确的创建分类变量，因为它是自动管理的。</li>
<li>空间被CPU高效地管理着，内存不会变成碎片。</li>
<li>只有局部变量。</li>
<li>受限于栈大小(取决于操作系统)。</li>
<li>变量不能调整大小。</li>
</ol>
</li>
<li>堆<ol>
<li>变量可以被全局访问。</li>
<li>没有内存大小限制。</li>
<li>访问比较慢(相对栈区访问)。</li>
<li>没有高效地使用空间，随着块内存的创建和销毁，内存可能会变成碎片。</li>
<li>必须手动管理内存(变量的创建和销毁由开发人员负责)。</li>
<li>变量大小可以用realloc()调整。</li>
</ol>
</li>
</ul>
<h2 id="2-2-调用的本质"><a href="#2-2-调用的本质" class="headerlink" title="2.2. 调用的本质"></a>2.2. 调用的本质</h2><p>C语言通过函数名后跟括号加上实参的形式进行函数调用。函数的调用是消耗栈区内存空间的，调用函数时，将函数定义所在的地址压入栈顶，栈顶指针”上移”，函数返回时，将压入的函数定义的地址弹出，栈顶指针”下移”，此次栈区空间被释放。若存在函数的多级调用而函数一直未返回(嵌套函数，递归函数)，栈区的内存空间会很快被消耗完，造成栈溢出。</p>
<h2 id="2-3-参数传递"><a href="#2-3-参数传递" class="headerlink" title="2.3. 参数传递"></a>2.3. 参数传递</h2><h3 id="2-3-1-实参与形参"><a href="#2-3-1-实参与形参" class="headerlink" title="2.3.1. 实参与形参"></a>2.3.1. 实参与形参</h3><p>实参：实际定义的变量，定义后就会分配内存，出现在主调函数中，在被调用后，会将实参所对应类型的值赋值给形参，实参变量也不能使用<br>形参：在函数定义时，形式上的参数，只有在函数被调用时才分配内存单元(栈区)，在调用结束时，即刻释放所分配的内存单元。因此，形参也是局部变量，作用域为在整个函数内部有效。函数调用结束返回主调函数后则不能再使用该形参变量。</p>
<ul>
<li>参数的传递是单向的，仅能是从实参传递给形参，形参无法将值传递给实参。</li>
<li>实参传递给形参的参数个数、类型和顺序都应相同，否则会进行数据类型的强制转换，可能出现数据丢失或者”类型不匹配”的错误。</li>
</ul>
<h3 id="2-3-2-值传递与引用传递"><a href="#2-3-2-值传递与引用传递" class="headerlink" title="2.3.2. 值传递与引用传递"></a>2.3.2. 值传递与引用传递</h3><p>仅将实参的值拷贝给形参，称为值传递。由于参数传递的单向性，形参在函数内部被修改值后，无法传递给外部的实参，即值传递不影响实参的值。</p>
<p>C语言没有实质上的引用传递，而是通过传入变量的地址而达到修改实参的目的。将实参的地址传递给形参，由于形参所指向的地址为实参变量的地址，所以修改形参对应地址中存储的值，就是修改实参变量的值，从而达到引用传递的目的。在C++中存在引用传递的语法，在形参变量前面加上<code>&amp;</code>符号意为是对实参的引用，在函数内部对形参变量的操作，就是对实参变量的操作。</p>
<h1 id="3-函数指针"><a href="#3-函数指针" class="headerlink" title="3. 函数指针"></a>3. 函数指针</h1><p>函数指针也是一种指针类型类型，可以通过函数指针进行函数的调用。</p>
<p>函数指针的定义语法为<code>[链接属性修饰符] 函数返回类型 (*指针变量名)(函数形参类型列表);</code></p>
<p>将函数的地址赋值给函数指针后，就可以通过该函数指针进行函数的调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个名为funcptr1的函数指针，未初始化</span></span><br><span class="line"><span class="type">void</span> (*funcptr1) (<span class="type">int</span> a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个名为funcptr2的函数指针，并初始化的指向func2</span></span><br><span class="line"><span class="type">void</span> (*funcptr2) (<span class="type">int</span> a) = func2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个名为funcptr3的函数指针，并初始化的指向func2</span></span><br><span class="line"><span class="type">void</span> (*funcptr3) (<span class="type">int</span> a) = &amp;func2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一般将函数指针定义为结构体的成员变量，用于构筑对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">man</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">  <span class="type">int</span> (*eat) (<span class="type">int</span> count);</span><br><span class="line">  <span class="type">int</span> (*run) (<span class="type">int</span> speed);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过函数指针调用func2</span></span><br><span class="line">funcptr2(<span class="number">2</span>);</span><br><span class="line">funcptr3(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>函数的定义的名称，实际上是一个符号，并非是真正意义上的函数地址，而直接通过函数名称对函数指针赋值实际是一种语法糖(减少程序书写量的写法)，<code>sizeof(func2) = 1</code>，而标准的写法即是对函数名进行取地址后赋值给函数指针。但在实际开发过程中，多数是funcptr2的赋值方式。</p>
<p>使用 <strong><code>typedef</code></strong> 定义自定义的函数指针类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个函数指针类型的自定义类型FUNC_TYPE</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*FUNC_TYPE)</span> <span class="params">(<span class="type">int</span> a)</span>;</span><br><span class="line">FUNC_TYPE funcptr4 = func2;</span><br><span class="line">funcptr4(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h1 id="4-函数返回值"><a href="#4-函数返回值" class="headerlink" title="4. 函数返回值"></a>4. 函数返回值</h1><p>在函数调用过程中，未使用static修饰定义的变量是动态存储的局部变量，局部变量是被压入栈区中存储的，当函数返回时，这些局部变量出栈，即局部变量已经被销毁，局部变量所占用的内存空间没有被清空，但是已经可以被分配给其他变量了，所以有可能在函数退出时，该内存已经被修改了，对于此局部变量来说已经是没有意义的值了。</p>
<p>在C语言中，通过<code>return</code>语句返回的值是被存储在寄存器中的，主调函数可以通过<code>=</code>等号直接取得函数的返回值。在16位程序中，返回值保存在<code>ax</code>寄存器中，32位程序中，返回值保持在<code>eax</code>寄存器中，64位程序的返回值，<code>edx</code>寄存器保存高32bit，<code>eax</code>寄存器保存低32bit。在函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，与内存没有关系。当退出函数的时候，局部变量可能被销毁，但是返回值已被存储到寄存器中，已与局部变量的生命周期无关。</p>
<p>寄存器的储存空间有限，当函数需要返回占用内存较大的结构体类型时，应返回该结构体的地址，且该结构体类型变量不应该是动态存储的局部变量，否则，返回动态存储变量的地址是无效的，甚至会对程序带来灾难。</p>
<h1 id="4-1-指针函数"><a href="#4-1-指针函数" class="headerlink" title="4.1. 指针函数"></a>4.1. 指针函数</h1><p>指针函数是指返回类型为指针的函数，指针则意味着其值是指向某个变量的地址，这里需要注意的是，若变量是在该函数中定义的栈区局部变量，返回该变量的指针是毫无意义的，且容易给程序带来严重的灾难，因为函数返回后，其栈顶指针下移，在这之上的栈区内存会被新定义的变量所覆盖，原变量的内存中的值以及毫无意义，甚至是错误的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">get_file_name1</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *p = <span class="built_in">strrchr</span>(path, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  <span class="type">char</span> file_name[<span class="number">64</span>] = &#123;<span class="string">&quot;\0&quot;</span>&#125;; </span><br><span class="line"></span><br><span class="line">  <span class="built_in">strncpy</span>(file_name, p ? p + <span class="number">1</span> : path, <span class="keyword">sizeof</span>(file_name));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> file_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">get_file_name2</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *p = <span class="built_in">strrchr</span>(path, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  <span class="type">char</span> *file_name = <span class="built_in">malloc</span>(<span class="number">64</span>); </span><br><span class="line"></span><br><span class="line">  <span class="built_in">strncpy</span>(file_name, p ? p + <span class="number">1</span> : path, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> file_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述例子中 <code>get_file_name1</code> 和 <code>get_file_name2</code> 都为一个指针函数，都返回一个指向 <code>char</code> 类型的指针(字符串)，但区别是 <code>get_file_name1</code> 返回的变量是定义在栈区内存的字符串变量，而 <code>get_file_name2</code> 返回的变量是定义在堆区内存的字符串变量，在函数返回后，栈顶指针下移，其上方内存区域的值会被后续新定义的变量所覆盖，其内存区域的值已变得毫无意义，而堆区中的内存在不被手动释放后是无法被其他变量进行覆盖的，但要记住在使用该变量后，释放掉该内存。</p>
<h1 id="5-匿名函数"><a href="#5-匿名函数" class="headerlink" title="5. 匿名函数"></a>5. 匿名函数</h1><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux笔记】Shell</title>
    <url>/posts/20230629/135252.html</url>
    <content><![CDATA[<h1 id="TODO-💤"><a href="#TODO-💤" class="headerlink" title="TODO 💤"></a>TODO 💤</h1>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
        <tag>脚本语言</tag>
      </tags>
  </entry>
</search>
